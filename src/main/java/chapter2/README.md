# Chapter2 객체지향 프로그래밍

### 01 영화 예매 시스템
#### 요구사항 살펴보기
* 예매자는 요금을 할인받을 수 있다
* 할인액은 두 가지 규칙에 의해 정해진다
    * 할인 조건: 가격의 할인 여부를 결정
        * 순서 조건: 상영 순번을 이용한 할인
        * 기간 조건: 상영 시작 시간을 이용한 할인
    * 할인 정책: 할인 요금 결정
        * 금액 할인 정책: 얘매 요금에서 일정 금액 할인
        * 비율 할인 정책: 예매 요금에서 일정 비율 금액 할인
* 영화는 하나의 할인 정책을 갖거나 할인 정책을 갖지 않는다
* 양화는 할인 정책을 갖으면 하나 이상의 할인 조건을 갖는다
* 할인 조건을 만족하면 할인 정책이 적용된다

### 02 객체지향 프로그래밍을 향해
#### 협력, 객체, 클래스
* 객체지향: 객체를 지향하는 것
* 객체지향 설계 접근 방식
    * 일반적인 방식
        1. 클래스를 결정
        2. 클래스에 어떤 속성과 메서드가 필요한지 고민
        * 객체지향의 본질과는 거리가 있음
    * 진정한 방식
        1. 어떤 클래스가 필요한지 고민하기 전에 어떤 객체들이 필요한지 고민 
            → `객체는 협력하는 공동체의 일원`
        2. 객체를 타입으로 분류하고 이를 클래스로 구현
* 객체는 독립적인 존재가 아닌 협력하는 공동체의 일원

> 클래스: 공통적인 상태와 행동을 공유하는 객체들을 추상화 한것

#### 도메인의 구조를 따르는 프로그램 구조
* 도메인: 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야
    * 영화 예매 도메인
* 도메인을 구성하는 개념들이 프로그램의 객체와 클래스로 연결 가능 
    → `요구사항 분석 부터 프로그램 구현까지 객체라는 추상화 기법 적용`
* 클래스와 클래스 간의 관계를 도메인을 구성하는 개념과 그들간의 관계와 유사하게 작성 
    → `도메인의 개념과 관계를 프로그램에 반영`

#### 클래스 구현하기
* 클레스의 경계를 구분 짓는 것 → `클래스의 어떤 부분을 외부에 공개하고 감출지 결정`
    * 객체의 자율성을 보장
    * 프로그래머에게 구현의 자유를 제공

##### 자율적인 객체
* 객체: 상태와 행동을 갖는 복합적인 존재
* 객체의 상태를 숨기고 행동만 외부에 공개할 경우 객체가 스스로 판단하고 행동하는 자율적인 존재라고 볼수 있음
    * 캡슐화: 데이터와 기능을 객체 내부로 함께 묶는 것
    * 접근 제어 매커니즘: 외부에서의 접근을 통제하는 것 (public, protected, private)
        * 외부에서 접근 가능: 퍼블릭 인터페이스
        * 외부에서 접근 불가능: 구현

##### 프로그래머의 자유
* 프로그래머의 역할을 클래스 작성자와 클라이언트 프로그래머로 구분
    * 클래스 작성자: 새로운 데이터 타입을 추가
    * 클라이언트 프로그래머: 데이터 타입을 사용
* 클라이언트 프로그래머에 대한 영향을 걱정하지 않고도 내부 구현을 마음대로 변경 
    → `구현 은닉`

#### 협력하는 객체들의 공동체
* 협력: 시스템의 어떤 기능을 구현하기 위해 객체들 사이에 이뤄지는 상호작용
* 영화를 예매하기 위해 Screening, Movie, Reservation 인스턴스는 서로의 메서드를 호출하며 상호작용

#### 협력에 관한 짧은 이야기
* 외부에 공개한 퍼블릭 인터페이스를 통해 내부 상태 접근
* 메시지 전송/수신을 통해 객체간의 상호작용이 가능

> 메시지 vs 메서드  
> * 메시지: 객체 간에 퍼블릭 인터페이스를 통해 요청 (다형성의 개념)
> * 메서드: 객체 스스로 메시지를 처리하는 방법을 자율적으로 결정

### 03 할인 요금 구하기
#### 할인 요금 계산을 위한 협력 시작하기
* 할인 요금 계산 요구사항
    * 할인 정책(DiscountPolicy)에는 금액 할인 정책(AmountDiscountPolicy), 비율 할인 정책(PercentDiscountPolicy) 이 존재
* 상속, 다형성 (추상화 원리 기반)

```java
// DiscountPolicy 객체에 대해 동일한 인터페이스를 통해 메시지 전달 → 상속, 다형성 원리
discountPolicy.calculateDiscountAmount()
```

#### 할인 정책과 할인 조건
* 할인 정책과 할인 조건간의 요구사항
    * 할인 정책(DiscountPolicy)은 할인조건(DiscountCondition)이 충족되면 적용
    * 금액 할인 정책(AmountDiscountPolicy)은 예매 요금에서 일정 금액을 할인
    * 비율 할인 정책(PercentDiscountPolicy)은 예매 요금에서 일정 비율을 할인
* 할인조건을 충족해야 하는 공통 로직, 할인 금액 계산 방식은 별도 로직
* 추상 클래스를 이용하여 부모 클래스에 중복 코드를 작성하고 자식 클래스가 이를 상속받는다

> 추상 클래스  
> : 하나 이상의 추상 메서드를 갖는 객체 생성이 불가능한 클래스 

> Template Method 패턴  
> : 부모 클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 디자인 패턴

> 오버라이딩 vs 오버로딩   
> * 오버라이딩: 부모 클래스에 정의된 같은 이름, 같은 파라미터 목록을 가진 메서드를 자식 클래스에서 재정의하는 경우
> * 오버로딩: 메서드 이름은 같지만 제공되는 파라미터 목록이 다른 경우

#### 할인 정책 구성하기
* 할인 정책 요구사항
    * 영화에 대해 단 하나의 할인 정책만 설정 가능
    * 할인 정책에는 여러 할인 조건이 설정 가능
* 생성자를 통해 필요한 정보를 강제하면 올바른 상태를 가진 객체를 보장

### 04 상속과 다형성
#### 컴파일 시간 의존성과 실행 시간 의존성
* 의존성: 어떤 클래스가 다른 클래스에 접근할 수 있는 경로를 가지거나 메서드를 호출할 경우
    * Movie와 DiscountPolicy 간의 의존성이 존재
    * Mivie와 AmountDiscountPolicy, PercentDiscountPolicy는 실행 시에 의존성 존재
* 코드의 의존성과 실행 시점의 의존성은 다르다
* 클래스 간의 의존성과 객체 간의 의존성은 다르다 → `유연하고 재사용 및 확장이 가능한 객체지향 설계의 특징`
* 코드를 이해하고 디버깅하기 어렵다
* 결국 클래스 간의 의존성과 객체 간의 의존성에는 정답은 없다

#### 차이에 의한 프로그래밍
* 상속: 두 클래스 사이의 관계를 정의하며, 코드를 재사용하도록 하는 기능 
* 차이에 대한 프로그래밍: 부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법

#### 상속과 인터페이스
* 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 수 있기 때문에 부모 클래스를 대신하여 사용가능
* 인터페이스: 객체가 이해할 수 있는 메시지의 목록을 정의하는 것
* 업캐스팅: 자식 클래스가 부모 클래스를 대신하는 것을 말하며 이는 자식 클래스가 부모 클래스로 자동 타입 캐스팅 됨을 의미

#### 다형성
* 다형성: 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력
* 컴파일 시간 의존성과 실행 시간 의존성이 다를 수 있다는 사실을 기반으로 한다
* 다형성은 객체들의 인터페이스가 동일해야 하며, 메시지에 대한 메서드를 실행 시점에 바인딩 한다

> 지연 바인딩, 동적 바인딩 vs 초기 바인딩, 정적 바인딩
> * 지연 바인딩, 동적 바인딩: 실행 시점에 실행될 함수나 프로시저를 결정
> * 초기 바인딩, 정젹 바인딩: 컴파일 시점에 실행될 함수나 프로시저를 결정

> 구현상속과 인터페이스 상속
> * 구현상속(서브 클래싱): 순수하게 코드를 재사용하기 위하여 사용
> * 인터페이스상속(서브 타이핑): 인터페이스를 공유하기 위하여 사용

#### 인터페이스와 다형성
* 구현은 공유할 필요가 없고 순수하게 인터페이스만 공유하고 싶을 때 인터페이스라는 프로그래밍 요소를 활용 

### 05 추상화와 유연성
#### 추상화의 힘
* 추상화의 계층만 살펴보면 요구사항의 정책을 높은 수준에서 서술할 수 있다
* 설계가 좀 더 유연해진다
* 세부 사항에 억눌리지 않고 상위 개념만으로 도메인의 중요한 개념을 설명할 수 있다
* 재사용 가능한 설계의 기본을 이루는 디자인 패턴이나 프레임워크 모두 추상화를 이용한 객체지향 메커니즘을 활용

#### 유연한 설계
* 할인 정책이 없는 경우
    * 할인 가격 계산시 예외처리 → 일관성이 무너짐
    * NoneDiscountPolicy 클래스를 추가 → 예외 케이스를 최소화하고 일관성을 유지
* 컨텍스트 독립성: 추상적인 클래스 설계로 인해 어떤 클래스와도 협력이 가능하며 특정한 상황에 묶여있지 않다
* 유연한 설계를 위해 추상화를 사용
 
#### 추상 클래스와 인터페이스 트레이드오프
* 할인 조건처리에 대한 개념적 결합
    * calculateDiscountAmount 할인 조건이 없는 경우 getDiscountAmount 호출하지 않음
    * NonDiscountPolicy 할인 조건이 없기 때문에 리턴값에 의미가 없음
* 트레이드오프
    * DiscountAmount 인터페이스 정의
    * NonDisplayPolicy 오퍼레이션 오버라이딩 

#### 코드 재사용
* 상속은 코드를 재사용하기 위해 널리 사용되는 방법이다
* 코드 재사용을 위해서는 상속보다는 합성이 더 좋은 방법
* 합성은 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법

#### 상속
* 부모 클래스의 구현이 자식 클레스에게 노출되기 때문에 캡슐화를 위반
* 부모 클래스와 자식 클래스가 강하게 결합되어 코드를 변경하기 어렵고 설계를 유연하지 못하게 만듬
* 상속은 부모 클래스와 자식 클래스 사이의 관계를 컴파일 시점에 결정, 실행 시점에 객체의 종류를 변경하는 것이 불가능

#### 합성
* 합성: 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법
    * DiscountPolicy의 calculateDiscountAmount
* 구현을 효과적으로 캡슐화
* 설계를 유연하게 만듬
* 상속은 클래스를 통해 강하게 결합되는데 합성은 메시를 통해 느슨하게 결합
