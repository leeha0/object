# Chapter5 책임 할당하기
* 데이터 중심 설계는 행동보다 데이터를 먼저 결정하고 협력이라는 문맥을 벗어나 고립된 객체의 상태에 초점을 맞추기 때문에 캡슐화를 위반하기 쉽고, 요소들 사이의 결합도가 높아지며, 코드를 변경하기 어려워진다
* 데이터 중심 설계로 인해 발생하는 문제점을 해결할 수 있는 가장 기본적인 방법은 `책임`에 초점을 맞추는 것이다
* 책임에 초점을 맞춰서 설계할 때 직면하는 가장 큰 어려움은 어떤 객체에게 어떤 책임을 할당할지를 결정하는 것이다
* `책임 할당` 과정은 일종의 트레이드오프의 활동이다
* `GRASP 패턴`을 통해 책임 할당의 어려움을 해결하기 위한 답을 제시

### 01 책임 주도 설계를 향해
* 데이터보다 `행동`을 먼저 결정하라
* `협력`이라는 문맥 안에서 `책임`을 결정하라 

#### 데이터보다 행동을 먼저 결정하라
* 클라이언트 관점에서 객체가 수행하는 행동이란 곤 `객체의 책임`을 의미한다
* 객체의 행동, 즉 책임을 먼저 결정한 후에 객체의 상태를 결정한다
* 적절한 객체에게 적절한 책임을 할당하는 것이 중요하다

#### 협력이라는 문맥 안에서 책임을 결정하라
* 책임의 품질은 협력에 적합한 정도로 결정된다
* 메시지를 전송하는 클라이언트의 의도에 적합한 책임을 할당해야 한다
* 메시지를 결정한 후에 객체를 선택해야 한다

#### 책임 주도 설계
* 시스템의 책임 파악
* 더 작은 책임으로 분할
* 책임을 수행할 적절한 객체 또는 역할을 찾아 할당
* 다른 객체의 도움이 필요할 경우 이를 책임질 적절한 객체 또는 역할을 찾음
* 해당 객체 또는 역할에게 책임 할당 (협력)

### 02 책임 할당을 위한 GRASP 패턴
* 크레이그 라만의 `GRASP 패턴`이 객체에게 책임을 할당할 때 지침으로 삼을 수 있는 원칙이다

#### 도메인 개념에서 출발하기
* 설계를 시작하기 전에 도메인에 대한 계략적인 모습을 그려 보는 것이 유용하다
* 도메인 개념들을 `책임 할당의 대상`으로 사용하면 코드에 도메인의 모습을 투영하기 수월하다
* 설계를 시작하기 위해 참고할 수 있는 `개념들의 모음` 정도로 간주

#### 정보 전문가에게 책임을 할당하라
* 애플리케이션이 제공해야 하는 기능을 애플리케이션의 책임으로 생각하는 것이다
* 애플리케이션에 대해 전송된 메시지로 간주하고 이 메시지를 책임질 첫 번째 객체를 선택하는 것으로 설계를 시작한다
* 객체는 상태와 행동을 통합한 캡슐화의 단위
* `정보 전문가 패턴`: 책임을 수행할 정보를 알고 있는 객체에게 책임을 할당하는 것이다
* `정보 전문가 패턴`은 객체에게 책임을 할당할 때 가장 기본이 되는 책임 할당 원칙이다 
* `정보 전문가 패턴`은 객체랑 상태와 행동을 함께 가지는 단위라는 객체지향의 가장 기본적인 원리를 책임 할당의 관점에서 표현

#### 높은 응집도와 낮은 결합도
* 기능을 구현하기 위해서는 무수히 많은 설계가 존재한다
* 무수히 많은 설계를 선택하는 기준은 `높은 응집도`와 `낮은 결합도`이며, 객체에 책임을 할당할 때 항상 고려해야 하는 기본원리이다
* 협력 패턴 중에서 높은 응집도와 낮은 결합도를 얻을 수 있는 설계가 있다면 그 설계를 선택해야 한다
* 낮은 결합도 패턴, 높은 응집도 패턴이라고 부른다
* `낮은 결합도 패턴`: `의존성`을 낮추고 변화의 영향을 줄여서 `재사용성`을 증가시킬 수 있을까?
* `높은 응집도 패턴`: `복잡성`을 관리할 수 있는 수준으로 유지할까?

#### 창조자에게 객체 생성 책임을 할당하라
* `창조자 패턴`: 객체를 생성할 책임을 어떤 객체에게 할당할지에 대한 지침 제공하며, 어떤 방식으로든 생성되는 객체와 연결되거나 관련될 필요가 있는 객체에 해당 객체를 생성할 책임을 맡기는 것이다
* 이미 결합돼 있는 객체에게 생성 책임을 할당하는 것은 설계의 전체적인 결합도에 영향을 미치지 않는다
* 결과적으로 창조자 패턴은 `낮은 결합도`를 유지하도록 한다

### 03 구현을 통한 검증
#### DiscountCondition 개선하기
* 하나 이상의 변경 이유를 가지기 때문에 응집도가 낮다
* `변경의 이유`에 따라 `클래스를 분리`해야 한다
* 변경의 이유를 파악하기 위한 방법
    * 인스턴스 변수가 초기화되는 시점
    * 함께 초기화되는 속성을 기준으로 코드를 분리
    * 메서드들이 인스턴스 변수를 사용하는 방식
    * 모든 메서드가 객체의 모든 속성을 사용한다면 클래스의 응집도는 높다고 볼 수 있다
* 속성 그룹과 해당 그룹에 접근하는 메서드 그룹을 기준으로 코드를 분리해야 한다
* 클래스의 응집도가 낮음을 판단하는 방법 3가지 
    * 클래스가 하나 이상의 이유로 변경 
    * 클래스의 인스턴스를 초기화 하는 시점에 따라 서로 다른 속성을 초기화
    * 메서드 그룹이 속성 그룹을 사용하는지 여부로 나뉜다면 

#### 타입 분리하기
* 독립적인 타입이 하나의 클래스 안에 공존
* 클래스로 분리
* 개별 클래스의 응집도 향상
* 클래스를 분리한 후에 설계의 관점에서 전체적인 결합도가 높아졌다

#### 다형성을 통해 분리하기
* 동일한 책임을 수행하고 있는 두 클래스를 하나의 역할로 봄
* 동일한 책임을 수행한다는 것은 동일한 역할을 수행한다는 것을 의미
* 역할은 협력 안에서 대체 가능성을 의미 
* 추상 클래스나 인터페이스를 통해 역할 구현 
* 추상클래스는 구현을 공유해야 할때 사용하며, 인터페이스는 구현을 공유할 필요가 업을 때 사용
* `다형성 패턴`: 객체의 타입에 따라 변하는 행동이 있디면 타입을 분리하고 변화하는 행동을 각 타입의 책임으로 할당하는 것이다

#### 변경으로부터 보호하기
* `변경 보호 패턴(Protected Variations)`: 변경을 캡슐화하도록 책임을 할당하는 것
* 책임할당 관점에서 캡술화를 설명한 것이다 
* 클래스를 변경에 따라 분리하고 인터페이스를 이용해 변경을 캡슐화
* 하나의 클래스가 여러 타입의 행동을 구현하고 있는 것처럼 보인다면 `클래스를 분해`하고 다형성 패턴(Polymorphism)에 따라 책임을 분산해라
* 예측 가능한 변경으로 인해 여러 클래스들이 불안정해진다면 변경 보호 패턴(Protected Variations)에 따라 안정적인 `인터페이스` 뒤로 변경을 캡슐화해라

#### Movie 클래스 개선하기
* 두 가지 타입을 하나의 클래스 안에 구현하여 응집도가 낮음
* 다형성 패턴을 사용하여 서로 다른 행동을 타입별로 분리 이렇게 하면 변경 보호 패턴을 이용해 타입의 종류를 안정적인 인터페이스 뒤로 캡슐화 할 수 있다는 것을 의미
* 구현을 공유하기 위해 추상 클래스를 사용
* 데이터가 아닌 책임을 중심으로 설계하라는 것이다. 객체에게 중요한 것은 상태가 아니라 행동이다. 객체지향 설계의 기본은 책임과 협력에 초점을 맞추는 것이다

#### 변경과 유연성
* 설계를 주도하는 것은 변경이다
* 코드를 이해하고 수정하기 쉽도록 최대한 단순하게 설계하는 것이다
* 코드를 수정하지 않고도 변경을 수용할 수 있도록 코드를 더 유연하게 만드는 것이다
* 더욱더 유연하게 만들기 위해서는 상속 대신 `합성`을 사용하는 것이 좋다
* 유연성의 정도에 따라 결합도를 조절하는 능력은 객체지향 개발자가 갖춰야 하는 중요한 기술 중 하나다.

### 04 책임 주도 설계의 대안
* 빠르게 목적한 기능을 수행하는 코드를 작성
* 리팩터링(Refactoring)을 통해 책임을 올바른 위치로 이동 
* `리팩터링`: 개선하기 위해 겉으로 보이는 동작은 바꾸지 않은 채 내부 구조를 변경하는 것을 말함

#### 메서드 응집도
* 긴 메서드는 응집도가 낮기 때문에 이해하기도 어렵고 재사용하기도 어려우며 변경하기도 어렵다
* `몬스터 메서드(Monster Method)`라고 부른다
* `주석`을 달아야 할 필요가 있다면 메서드의 응집도는 낮은 것이다
* 주석을 추가하는 대신 메서드를 작게 분해해서 각 메서드의 응집도를 높여라
* 짧고, 이해하기 쉬운 이름의 메서드를 사용하고, 메서드가 잘 나누어져 있을때 
    * 다른메서드에서 활용될 확률이 높아진다
    * `오버라이딩` 하기 쉽다
    * 고수준의 메서드를 볼 때 일련의 주석을 읽는 것 같은 느낌이듬
* 메서드를 응집도 있는 수준으로 분해한다
* 코드를 작은 메서드들로 분해하면 전체적인 흐름을 이해하기 쉬워진다
* 코드를 변경하기 더 쉽다
* 단 하나의 이유에 의해 변경이 일어난다
* 작고, 명확하며, 한 가지 일에 집중하는 응집도 높은 메서드들을 담고 있다
* 메서드를 잘게 조개서 메서드 레벨에서 응집도를 높였지만 메서드를 포함하는 클래스는 여전히 응집도가 낮다 
* 적절한 객체에게 메서드를 분배해야 한다

#### 객체를 자율적으로 만들자
* 자신이 소유하고 있는 데이터를 자기 스스로 처리하도록 만드는 것이 자율적인 객체를 만드는 지름길이다.
* 인자에 정의된 클래스중 하나로 이동시키는 경우가 일반적인다
* 데이터를 사용하는 메서드를 데이터를 가진 클래스로 이동시키고 나면 캡슐화와 높은 응집도, 낮은 결합도를 가지는 설계를 얻게 된다
